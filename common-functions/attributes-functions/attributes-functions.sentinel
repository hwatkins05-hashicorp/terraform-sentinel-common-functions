# Common functions that make use of attributes

##### Imports #####
import "tfconfig/v2" as tfconfig
import "tfplan/v2" as tfplan
import "tfstate/v2" as tfstate
import "strings"
import "types"

##### Functions #####

### evaluate_attribute ###
# Evaluates an attribute
# In general, the attribute should be a top-level attribute of item, but
# we do special processing for attributes with form "config.x"
# `item` is the item with the attribute
# `attribute` is the attribute
func evaluate_attribute(item, attribute) {
  # Split the attribute into a list, using "." as the separator
  attributes = strings.split(attribute, ".")
  if length(attributes) > 2 {
    print("An attribute passed to evaluate_attribute can only have 1 or 2 fields")
    return null
  }
  if attributes[0] is "config" {
    config = item.config[attributes[1]] else {}
    if "constant_value" in config {
      # Found constant_value in config
      return config.constant_value
    } else if "references" in config {
      # Found references in config
      return config.references
    } else {
      # Did not find constant_value or references in config
      return null
    }
  } else {
    # Return the original attribute or the item
    return item[attribute]
  }
}

### attribute_not_in_list ###
# Filter a list of items such as providers to those with a specified
# attribute (attr) that is not in a given list of allowed values (allowed).
# The parameter, attr, can only be a top-level attribute of the collection, items.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
# If you want to disallow null, include "null" in the list (forbidden).
func attribute_not_in_list(items, attr, allowed, prtmsg) {
  violators = {}
  # messages = {}

  # Iterate over items
  for items as index, item {
    val = evaluate_attribute(item, attr) else null
    # Check if the value is null
    if val is null {
      val = "null"
    }
    # Process lists and maps
    if types.type_of(val) in ["list", "map"] { // Config case
      above_helper(val, index, attr, allowed, prtmsg)
    } else {
      # Process single item
      if val not in allowed {
        # Add the item and a warning message to the violators list
        # message = to_string(index) + " has " + to_string(attr) +
        #           " with value " + to_string(val) +
        #           " that is not in the allowed list: " +
        #           to_string(allowed)
        violators[index] = item
        # messages[index] = message
        # if prtmsg {
        #   print(message)
        # }
      } // end if single item not matches
    } // end single item
  } // end for items
  return {"items":violators/*,"messages":messages*/}
}

func above_helper(v, index, attr, allowed/*, prtmsg*/) {
    # Process lists and maps
    # message = ""
    # Check each item of list or map
    for v as i, val {
        if val not in allowed {
            # Add the item and a warning message to the violators list
            # message = general.to_string(index) + " has " + general.to_string(attr) + " with value " +
            #         general.to_string(val) + " that is not in the allowed list: " +
            #         general.to_string(allowed)
        //}
        //if message is not "" {
            # Add the item and warning message to the violators list
            violators[index] = item
            # messages[index] = message
            # if prtmsg {
            # print(message)
            # }
        } // end message not ""
    } // end for
}

### attribute_in_list ###
# Filter a list of items such as providers to those with a specified
# attribute (attr) that is in a given list of forbidden values (forbidden).
# The parameter, attr, can only be a top-level attribute of the collection, items.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
# If you want to disallow null, include "null" in the list (forbidden).
func attribute_in_list(items, attr, forbidden, prtmsg) {
  violators = {}
  messages = {}

  # Iterate over items
  for items as index, item {
    val = evaluate_attribute(item, attr) else null
    # Check if the value is null
    if val is null {
      val = "null"
    }
    # Process lists and maps
    if types.type_of(val) in ["list", "map"] {
      # message = ""
      # Check each item of list or map
      for val as i, v {
        if v in forbidden {
          # Add the item and a warning message to the violators list
        #   message = to_string(index) + " has " + to_string(attr) + " with value " +
        #             to_string(v) + " that is in the forbidden list: " +
        #             to_string(forbidden)
        # }
        # if message is not "" {
          # Add the item and warning message to the violators list
          violators[index] = item
      		# messages[index] = message
          # if prtmsg {
          #   print(message)
          # }
        } // end message not ""
      } // end for
    } else {
      # Process single item
      if val in forbidden {
        # Add the item and a warning message to the violators list
        # message = to_string(index) + " has " + to_string(attr) +
        #           " with value " + to_string(val) +
        #           " that is in the forbidden list: " +
        #           to_string(forbidden)
        violators[index] = item
        # messages[index] = message
        # if prtmsg {
        #   print(message)
        # }
      } // end if single item not matches
    } // end single item
  } // end for items

  return {"items":violators,"messages":messages}
}

### attribute_does_not_match_regex ###
# Filter a list of items such as resources to those with a specified
# attribute (attr) that does not match a regular expression (expr).
# The parameter, attr, can only be a top-level attribute of items or
# an attribute in the form "config.x".
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
func attribute_does_not_match_regex(items, attr, expr, prtmsg) {
  violators = {}
	# messages = {}
  for items as index, item {
    val = evaluate_attribute(item, attr) else null
    if val is null {
      # Add the item and a warning message to the violators list
      # message = to_string(index) + " has " + to_string(attr) +
      #           " that is null or undefined. " + "It is supposed to " +
      #           "match the regex " + to_string(expr)
      violators[index] = item
			# messages[index] = message
      # if prtmsg {
      #   print(message)
      # }
    } else {
      # Process lists and maps
      if types.type_of(val) in ["list", "map"] {
        # message = ""
        # Check each item of list or map
        for val as i, v {
          if v not matches expr {
            # Add to the warning message
            # message += to_string(index) + " has " + to_string(attr) +
            #           " with value " + to_string(v) +
            #           " that does not match the regex " + to_string(expr) + "\n"
          # }
          # if message is not "" {
            # Add the item and warning message to the violators list
            violators[index] = item
      			# messages[index] = message
            # if prtmsg {
            #   print(message)
            # }
          } // end message not ""
        } // end for
      } else {
        # Process single item
        if val not matches expr {
          # Add the item and a warning message to the violators list
          # message = to_string(index) + " has " + to_string(attr) +
          #           " with value " + to_string(val) +
          #           " that does not match the regex " + to_string(expr)
          violators[index] = item
          # messages[index] = message
          # if prtmsg {
          #   print(message)
          # }
        } // end if single item not matches
      } // end single item
    } // end not null
  } // end for items
  return {"items":violators,"messages":messages}
}

### attribute_matches_regex ###
# Filter a list of items such as resources to those with a specified
# attribute (attr) that matches a regular expression (expr).
# The parameter, attr, can only be a top-level attribute of items or
# an attribute in the form "config.x".
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
# If you want to match null, set expr to "null".
func attribute_matches_regex(items, attr, expr, prtmsg) {
  violators = {}
	# messages = {}
  for items as index, item {
    val = evaluate_attribute(item, attr) else null
    if val is null {
      val = "null"
    }
    # Process lists and maps
    if types.type_of(val) in ["list", "map"] {
      # message = ""
      # Check each item of list or map
      for val as i, v {
        if v matches expr {
          # Add to the warning message
          # message += to_string(index) + " has " + to_string(attr) +
          #           " with value " + to_string(v) +
          #           " that matches the regex " + to_string(expr) + "\n"
        # }
        # if message is not "" {
          # Add the item and warning message to the violators list
          violators[index] = item
          # messages[index] = message
          # if prtmsg {
          #   print(message)
          # }
        } // end message not ""
      } // end for
    } else {
      # Process single item
      if val matches expr {
        # Add the item and a warning message to the violators list
        # message = to_string(index) + " has " + to_string(attr) +
        #           " with value " + to_string(val) +
        #           " that matches the regex " + to_string(expr)
        violators[index] = item
        # messages[index] = message
        # if prtmsg {
        #   print(message)
        # }
      } // end if single item not matches
    } // end single item
  } // end for items
  return {"items":violators,"messages":messages}
}